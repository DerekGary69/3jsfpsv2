<!DOCTYPE html>
<html>
<head>
    <title>Three.js Project</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "cannon-es": "https://unpkg.com/cannon-es/dist/cannon-es.js"
            }

        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es'
        import CannonDebugger from './node_modules/cannon-es-debugger/dist/cannon-es-debugger.js';
        // import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';
        import { PointerLockControlsCannon } from './pointerLockControlsCannon.js';
        import Stats from './node_modules/three/examples/jsm/libs/stats.module.js';
        import { GLTFLoader } from './node_modules/three/examples/jsm/loaders/GLTFLoader.js';
        import {threeToCannon, ShapeType} from './node_modules/three-to-cannon/dist/three-to-cannon.modern.js';
        import { EffectComposer } from './node_modules/three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from './node_modules/three/examples/jsm/postprocessing/RenderPass.js';
        import { Sky } from './node_modules/three/examples/jsm/objects/Sky.js'
        import { GUI } from './node_modules/three/examples/jsm/libs/lil-gui.module.min.js'
        import {GLTFExporter} from './node_modules/three/examples/jsm/exporters/GLTFExporter.js';

        const width = window.innerWidth, height = window.innerHeight;

        const timeStep = 1 / 60
        let lastCallTime = performance.now()
        let scene, camera, renderer, composer, controls, stats;
        let sunLight, sunTarget, sunHelper;
        let sky, sun;
        let defaultMaterial, defaultGeometry, defaultRadius;
        let world, cannonDebugger;
        let slipMaterial;
        let playerBody, playerMesh, playerShape, playerMaterial;
        let moveSpeed = 10;

        let cubeCamera, cubeRenderTarget;

        let spotLight, spotLightHelper, spotLightTarget;

        let keys = {};

        const meshMap = new Map();
        
        init();

        function init() {
            // init
            sceneSetup();
            cameraSetup();
            rendererSetup();
            
            statsSetup();
            physicsSetup();
            createObjects();
            lightSetup();
            skySetup();
            
            // inputSetup();
            createPlayer();
            controlsSetup();
            loadGLTF('assets/coltesting.glb', 1);
        }

        function sceneSetup() {
            // scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0x87ceeb );

            scene.fog = new THREE.Fog( 0x87ceeb, 1, 1000 );

        }

        function cameraSetup() {
            // camera
            camera = new THREE.PerspectiveCamera( 70, width / height, 0.01, 100 );
           
            camera.lookAt(0, 0, 0);
        }

        function rendererSetup() {
            // renderer
           
            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.VSMShadowMap;

            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.3;
            
            document.body.appendChild( renderer.domElement );

            
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
        }

        function lightSetup() {
            // lights
            // const light = new THREE.DirectionalLight( 0xffffff, 1 );
            // light.position.set( 5, 5, 5 );
            // light.castShadow = true;
            // light.shadow.mapSize.width = 1024;
            // light.shadow.mapSize.height = 1024;
            // light.shadow.camera.near = 0.5;
            // light.shadow.camera.far = 500;

            // scene.add( light );

            // const ambientLight = new THREE.AmbientLight( 0xffffff, 0.5 );
            // scene.add( ambientLight );

            sunLight = new THREE.DirectionalLight(0xFFFFFF, 5);
            sunLight.position.set(5, 10, 5);
            sunLight.castShadow = true;
            sunLight.shadow.bias = -0.0001;
            const size = 50; 
            sunLight.shadow.camera.left = -size;
            sunLight.shadow.camera.right = size;
            sunLight.shadow.camera.top = size;
            sunLight.shadow.camera.bottom = -size;
            sunLight.shadow.mapSize.width = 1048; // Default is 512
            sunLight.shadow.mapSize.height = 1048; // Default is 512
            sunLight.shadow.radius = 1;

            sunTarget = new THREE.Object3D();
            sunTarget.position.set(0, 0, 0);

            spotLightTarget = new THREE.Object3D();
            spotLightTarget.position.set(0, 0, -13);
            camera.add(spotLightTarget);


            sunLight.target.position.set(sunTarget.position.x, sunTarget.position.y, sunTarget.position.z);
            scene.add(sunLight);

            let debugSun = new THREE.DirectionalLight(0xFFFFFF, 3);
            debugSun.position.set(5, 10, 5);
            // debugSun.target = (new THREE.Object3D()).position.set(0, 0, 0);
            scene.add(debugSun);

            // sunHelper = new THREE.DirectionalLightHelper(sunLight, 5);
            // scene.add(sunHelper);

            spotLight = new THREE.SpotLight(0xFFFFFF, 0);
            spotLight.position.set(0, 0, -0.1);
            spotLight.target = spotLightTarget;
            spotLight.angle = Math.PI / 4;
            spotLight.penumbra = 0.3;
            spotLight.decay = 0.7;
            spotLight.distance = 10;

            spotLight.castShadow = false;

            camera.add(spotLight);

            window.addEventListener('keydown', (event) => {
                if (event.key === 'f') {
                    spotLight.intensity = spotLight.intensity === 0 ? 3 : 0;
                }
            });

            // spotLightHelper = new THREE.SpotLightHelper(spotLight);
            // scene.add(spotLightHelper);


        }

        function skySetup() {
            sky = new Sky();
            sky.scale.setScalar( 450000 );
            scene.add( sky );
            

            sun = new THREE.Vector3();


            cubeRenderTarget = new THREE.WebGLCubeRenderTarget( 256 );
				cubeRenderTarget.texture.type = THREE.HalfFloatType;

				cubeCamera = new THREE.CubeCamera( 100, 100, cubeRenderTarget );

				//

				let material = new THREE.MeshStandardMaterial( {
					envMap: cubeRenderTarget.texture,
					roughness: 0.05,
					metalness: 1
				} );

                const geometry = new THREE.SphereGeometry( 1, 32, 16 );
                const mesh = new THREE.Mesh( geometry, material );
                scene.add( mesh );
                mesh.position.set(0, 20, 0);
                cubeCamera.position.copy( mesh.position );
                scene.environment = cubeRenderTarget.texture;

            /// GUI

				const effectController = {
					turbidity: 10,
					rayleigh: 3,
					mieCoefficient: 0.005,
					mieDirectionalG: 0.975,
					elevation: 2,
					azimuth: 180,
					exposure: renderer.toneMappingExposure
				};

				function guiChanged() {

					const uniforms = sky.material.uniforms;
					uniforms[ 'turbidity' ].value = effectController.turbidity;
					uniforms[ 'rayleigh' ].value = effectController.rayleigh;
					uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
					uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;

					const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
					const theta = THREE.MathUtils.degToRad( effectController.azimuth );

					sun.setFromSphericalCoords( 1, phi, theta );

                    sunLight.position.copy(sun);

					uniforms[ 'sunPosition' ].value.copy( sun );


                    // Calculate the zenith angle cosine
                    const sunDirection = new THREE.Vector3().copy(sunLight.position).normalize();
                    const zenithAngleCos = sunDirection.y; // Assuming the up direction is (0, 1, 0)

                    // Calculate the sun intensity
                    const intensity = sunIntensity(zenithAngleCos);

                    // Set the light intensity
                    sunLight.intensity = intensity
                    console.log(sunLight.intensity);

					renderer.toneMappingExposure = effectController.exposure;
					renderer.render( scene, camera );



				}

				const gui = new GUI();

				gui.add( effectController, 'turbidity', 0.0, 20.0, 0.1 ).onChange( guiChanged );
				gui.add( effectController, 'rayleigh', 0.0, 4, 0.001 ).onChange( guiChanged );
				gui.add( effectController, 'mieCoefficient', 0.0, 0.1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, 'mieDirectionalG', 0.0, 1, 0.001 ).onChange( guiChanged );
				gui.add( effectController, 'elevation', 0, 90, 0.1 ).onChange( guiChanged );
				gui.add( effectController, 'azimuth', - 180, 180, 0.1 ).onChange( guiChanged );
				gui.add( effectController, 'exposure', 0, 1, 0.0001 ).onChange( guiChanged );

				guiChanged();
            
            
            
            
        }

        function calculateSunPosition(time) {
            const dayDuration = 30; // seconds in a day
            const dayTime = time + 10 % dayDuration;
            const dayPercentage = dayTime / dayDuration;
            

            // Elevation goes from -90 to 90 to -90
            const elevation = (dayPercentage * 360 - 180);

            // Azimuth goes from 180 to -180
            const azimuth = (dayPercentage * 360 - 180);


            return { elevation, azimuth, dayPercentage };
        }

        function updateSunPosition(time) {
            const { elevation, azimuth, dayPercentage } = calculateSunPosition(time);    

            const phi = THREE.MathUtils.degToRad( 90 - elevation );
            const theta = THREE.MathUtils.degToRad( azimuth );

            sun.setFromSphericalCoords( 1, phi, theta );
            sunLight.position.copy(sun);

            sky.material.uniforms[ 'sunPosition' ].value.copy( sun );

            // Calculate the zenith angle cosine
            const sunDirection = new THREE.Vector3().copy(sunLight.position).normalize();
            const zenithAngleCos = sunDirection.y; // Assuming the up direction is (0, 1, 0)

            // Calculate the sun intensity
            const intensity = sunIntensity(zenithAngleCos);

            // Set the light intensity
            sunLight.intensity = intensity

            // console.log(sunLight.intensity);
            // sunHelper.update();
        }

        function sunIntensity(zenithAngleCos) {
            const cutoffAngle = 1.6110731556870734;
            const steepness = 1.5;
            const EE = 10.0;

            zenithAngleCos = Math.max(-1, Math.min(1, zenithAngleCos));
            return EE * Math.max(0, 1 - Math.exp(-(cutoffAngle - Math.acos(zenithAngleCos)) / steepness));
        }

        function controlsSetup() {
            // controls
            // controls = new OrbitControls( camera, renderer.domElement );
            // controls.enableDamping = true;

            controls = new PointerLockControlsCannon(camera, playerBody)
            scene.add(controls.getObject())
            
            window.addEventListener('click', () => {
                controls.lock()
            })

            controls.addEventListener('lock', () => {
                controls.enabled = true
                // instructions.style.display = 'none'
            })

            controls.addEventListener('unlock', () => {
                controls.enabled = false
                // instructions.style.display = null
            })
        }

        function statsSetup() {
            // stats
            stats = new Stats();
            document.body.appendChild( stats.dom );
        }

        function physicsSetup() {
            // physics
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0), // m/s²
            })

            world.allowSleep = true

            cannonDebugger = new CannonDebugger(scene, world, {
                onInit(body, mesh) {
                    // Toggle visibiliy on "d" press
                    mesh.visible = false
                    document.addEventListener('keydown', (event) => {
                    if (event.key === '=') {
                        mesh.visible = !mesh.visible
                    }
                    })
                },
            })

            slipMaterial = new CANNON.Material('physics')
                const physics_physics = new CANNON.ContactMaterial(slipMaterial, slipMaterial, {
                friction: 0.0,
                restitution: 0.3,
            })
        }
        
        function createObjects() {
            // objects
            defaultMaterial = new THREE.MeshNormalMaterial();
            defaultGeometry = new THREE.BoxGeometry( 0.2, 0.2, 0.2 );
            defaultRadius = 1;

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry( 100, 100, 100, 100 ),
                new THREE.MeshStandardMaterial( { color: 0x808080, side: THREE.DoubleSide } )
            );

            floor.receiveShadow = true;

            floor.rotation.x = - Math.PI / 2;
            floor.position.y = -1;
            scene.add( floor );

            const groundBody = new CANNON.Body({
                type: CANNON.Body.STATIC, // can also be achieved by setting the mass to 0
                shape: new CANNON.Plane(),
            })

            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0) // make it face up
            groundBody.position.set(0, -1, 0) // m
            world.addBody(groundBody)

            const sphereBody = new CANNON.Body({
                mass: 5, // kg
                shape: new CANNON.Sphere(defaultRadius),
            })
            sphereBody.position.set(0, 10, 0) // m
            world.addBody(sphereBody)

            sphereBody.damping = 0.9
            sphereBody.angularDamping = 0.99

            const geometry = new THREE.SphereGeometry(defaultRadius)
            const sphereMesh = new THREE.Mesh(geometry, defaultMaterial)
            scene.add(sphereMesh)

            meshMap.set(sphereBody, sphereMesh)

            const boxBody = new CANNON.Body({
                mass: 5, // kg
                shape: new CANNON.Box(new CANNON.Vec3(0.1, 0.1, 0.1)), // m
            })
            boxBody.position.set(0, 5, 0) // m
            world.addBody(boxBody)

            const box = new THREE.Mesh( defaultGeometry, defaultMaterial );
            scene.add( box );

            meshMap.set(boxBody, box)
            
        }


        function inputSetup() {
            let keyDownListener = function(event) {
                event.preventDefault();
                // console.log(event.code);
                keys[event.code] = true;
                console.log(keys);
            };

            let keyUpListener = function(event) {
                event.preventDefault();
                // console.log(event.code);
                keys[event.code] = false;
            };

            window.addEventListener('keydown', keyDownListener);
            window.addEventListener('keyup', keyUpListener);
        }

        function createPlayer() {
            playerMaterial = slipMaterial;

            playerShape = new CANNON.Sphere(0.5)

            playerBody = new CANNON.Body({ mass: 5, material: playerMaterial})
            playerBody.addShape(playerShape, new CANNON.Vec3(0, 0, 0))
            // playerBody.fixedRotation = true
            // playerBody.updateMassProperties()

            
            // playerBody.position.set(-8, 5, 0)
            
            playerBody.linearDamping = 0.99
            playerBody.angularDamping = 0.99
            playerBody.allowSleep = false
            
            world.addBody(playerBody)
        }

        // animation

        function animate() {

            const time = performance.now() / 1000
            const dt = time - lastCallTime
            lastCallTime = time

            if (controls.enabled) {
                world.step(timeStep, dt)
                cannonDebugger.update()

                for (const [body, mesh] of meshMap) {
                    mesh.position.copy(body.position)
                    mesh.quaternion.copy(body.quaternion)
                }
                
                // updateSunPosition(time)

                // cubeCamera.update(renderer, scene)

                // spotLightHelper.update()

            }

            controls.update(dt)
            renderer.render(scene, camera)
            stats.update()
        }


        function loadGLTF(url, scale) {
            const loader = new GLTFLoader();
            loader.load( url, function ( gltf ) {
                // gltf.scene.scale.set(0.9, 0.9, 0.9);

                gltf.scene.traverse( function ( child ) {
                    if ( child.isMesh ) {
                        if (child.material.isMeshStandardMaterial) {
                            child.material.metalness = 0;
                            child.material.roughness = 0.5;
                            // child.material.envMapIntensity = globalEnvMapIntensity;
                            // matList.push(child.material);
                        } else if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                if (mat.isMeshStandardMaterial) {
                                    mat.metalness = 0;
                                    mat.roughness = 0.5;
                                    // mat.envMapIntensity = globalEnvMapIntensity;
                                    // matList.push(mat);
                                }
                            });
                        }
                        child.castShadow = true;
                        child.receiveShadow = true;                       

                        let shapeType;
                        switch (child.userData.shapeType) {
                            case 'SPHERE':
                                shapeType = ShapeType.SPHERE;
                                sphereCollision(child, child.userData.radius || 0.5);
                                break;
                            case 'BOX':
                                shapeType = ShapeType.BOX;
                                boxCollision(child, child.userData.size);
                                break;
                            case 'CYLINDER':
                                shapeType = ShapeType.CYLINDER;
                                cylinderCollision(child, child.userData.radiusTop, child.userData.radiusBottom, child.userData.height, child.userData.resolution);
                                break;
                            case 'HULL':
                                shapeType = ShapeType.HULL;
                                hullCollision(child);
                                break;
                            case 'MESH':
                                shapeType = ShapeType.MESH;
                                meshCollision(child);
                                break;
                            default:
                                //no collision
                            break;
                        }
                    }
                } );
                scene.add( gltf.scene );
            } );
        }

        function sphereCollision(child, radius) {
            let sphereBody = new CANNON.Body({mass: child.userData.mass || 0});
            let sphere = new CANNON.Sphere(radius);
            sphereBody.addShape(sphere);
            sphereBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(sphereBody);
            meshMap.set(sphereBody, child);
        }

        function boxCollision(child, size) {
            let boxBody = new CANNON.Body({mass: child.userData.mass || 0});
            let dimensions;
            if(size !== undefined) {
                dimensions = new CANNON.Vec3(size.x, size.y, size.z);
            } else {
                //get dimensions from mesh
                let box = new THREE.Box3().setFromObject(child);
                dimensions = new CANNON.Vec3((box.max.x - box.min.x)/2, (box.max.y - box.min.y)/2, (box.max.z - box.min.z)/2);
            }
            let box = new CANNON.Box(dimensions);
            boxBody.addShape(box);
            boxBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(boxBody);
            meshMap.set(boxBody, child);
        }

        function cylinderCollision(child, radiusTop, radiusBottom, height, resolution) {
            let cylinderBody = new CANNON.Body({mass: child.userData.mass || 0});
            radiusTop = radiusTop ? radiusTop : radiusBottom ? radiusBottom : 0.5;
            radiusBottom = radiusBottom ? radiusBottom : radiusTop ? radiusTop : 0.5;
            let cylinder = new CANNON.Cylinder(radiusTop, radiusBottom, height, resolution);
            cylinderBody.addShape(cylinder);
            cylinderBody.position.set(child.position.x, child.position.y, child.position.z);
            world.addBody(cylinderBody);
            meshMap.set(cylinderBody, child);
        }

        function hullCollision(child) {
            let hullType = child.userData.hullType || 'mesh';
            let hullBody = new CANNON.Body({mass: child.userData.mass || 0});
            let shape;
            switch(hullType) {
                case 'mesh':
                    //create hull from mesh
                    shape = threeToCannon(child, {type: ShapeType.HULL});
                    
                    
                    hullBody.addShape(shape.shape);
                break;
                case 'colobject':
                    //create hull from child with name ending in .col
                    let colMesh = child.children.filter(child => child.name.endsWith('col'))[0];
                    console.log(colMesh);
                    shape = threeToCannon(colMesh, {type: ShapeType.HULL});
                    hullBody.addShape(shape.shape, shape.offset, shape.orientation);
                    child.remove(colMesh);
                break;
                case 'vhacd':
                    //child has many children, each a convex hull
                    //they will have _hull_ in their name
                    let hulls = child.children.filter(child => child.name.includes('_hull_'));
                    hulls.forEach(hull => {
                        // hull position is (5.82892, -0.193318, -0.683173);
                        //offset should be the difference between the child and the hull object
                        let offset = new CANNON.Vec3(
                            hull.position.x + child.position.x,
                            hull.position.y + child.position.y,
                            hull.position.z + child.position.z
                        );
                        offset = offset.vsub(child.position);
                        let hullShape = threeToCannon(hull, {type: ShapeType.HULL});
                        hullBody.addShape(hullShape.shape, offset);
                        child.remove(hull);
                    });
                    
                break;
            }
            hullBody.position.set(child.position.x, child.position.y, child.position.z);
            hullBody.quaternion.set(child.quaternion.x, child.quaternion.y, child.quaternion.z, child.quaternion.w);
            world.addBody(hullBody);
            meshMap.set(hullBody, child);
        }
        
    </script>
</body>
</html>